---
title: es6新增的声明变量的两种方式
---

#### es6的方法(重点)

##### ES6新增的两种声明变量的方式：

1.使用关键字let对变量进行申明,特点如下：

a.没有变量提升，必须先声明再使用；

b.存在''暂存死区''(存在但无法访问)；

c.存在块级作用域，只能在块级作用域或者子块级作用域内使用；

d.不能重复声明同一个变量名;

e.声明的变量不能挂载在window上;

2.使用关键词const对常量进行申明,const具有和let一样的特点，但是比let多出以下特点:

a.声明常量时必须进行初始化;

b.声明的常量为简单数据类型时，不可直接进行修改;

c.声明的常量为复杂数据类型时，可以对复杂数据内的属性或者方法进行修改，这是因为，复杂数据类型声明的是地址值，修改数据内属性或方法并不改变常量的地址值；

对于块级作用域的使用:
在我们使用for循环时：
for(var i = 0;i<5; i++) {
    console.log('hello')
}

console.log(i) //var声明的变量是没有块级作用域，所以在for循环的外面可以输出i的值，且i = 5；

但是如果在for循环内使用，let或者const声明变量，则会存在块级作用域

for(let i = 0; i<5; i++) {
    console.log('hello')
}
console.log(i) 

//这里会报错，因为let是在for循环内声明的变量，存在着块级作用域，而打印出来的i处于全局范围内，故无法读取i

暂存死区的解释：

function foo() {
    var num = 10
    return function fn() {
        console.log(num)
        let num = 5
    }
}
foo()


在调用函数后，返回的值会是报错，以前通过var声明的变量，通过作用域链，如果在当前局部作用域找不到变量，会向上一级寻找；但是let声明的变量不行，js在解析过程中找到当前作用域存在需要打印的变量，但是由于let声明的变量无法进行变量提升，必须先声明再使用，于是造成系统报错，且报错意思为，在当前作用域找到了变量，但是无法使用，形成了暂存死区